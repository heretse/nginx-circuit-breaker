package main

import (
	"encoding/json"
	"log"
	"net"
	"net/http"
	"os"
	"strconv"
	"time"
)

type Response struct {
	Message string `json:"message"`
}

type Dispatcher struct {
	errorMode bool
}

func main() {
	var d = Dispatcher{false}

	mux := http.NewServeMux()

	mux.HandleFunc("/health", d.healthHandler)
	mux.HandleFunc("/", d.requestHandler)

	log.Fatal(http.ListenAndServe(":8000", mux))
	log.Printf("HTTP service listening on 8000")
}

func (d *Dispatcher) requestHandler(w http.ResponseWriter, r *http.Request) {
	var sleep, _ = strconv.Atoi(r.URL.Query().Get("sleep"))
	if r.Method == "POST" {
		d.errorMode = !d.errorMode
		sendResponse(w, r, 0, "Toggled error mode", http.StatusOK)
	} else if d.errorMode == true {
		sendResponse(w, r, sleep, "Something went wrong", http.StatusServiceUnavailable)
	} else {
		sendResponse(w, r, sleep, "Success", http.StatusOK)
	}
}

func (d *Dispatcher) healthHandler(w http.ResponseWriter, r *http.Request) {
	sendResponse(w, r, 0, "OK", http.StatusOK)
}

func sendResponse(w http.ResponseWriter, r *http.Request, timeout int, response string, status int) {
	var logger = log.New(os.Stdout, "", 0)
	time.Sleep(time.Duration(timeout) * time.Millisecond)
	if status == http.StatusOK {
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(Response{Message: response})
	} else {
		http.Error(w, response, status)
	}

	logCombined(logger, r, status)
	logHostname()
}

func logCombined(logger *log.Logger, r *http.Request, status int) {
	t := time.Now()
	logger.Printf(r.RemoteAddr + " [" + t.Format("02/Jan/2006:15:04:05") + "] \"" + r.Method + " " + r.RequestURI + " " + r.Proto + "\" " + strconv.Itoa(status) + " \"" + r.Referer() + "\" " + "\"" + r.UserAgent() + "\"")
}

func logHostname() {
	var hostname, _ = os.Hostname()
	ifaces, _ := net.Interfaces()
	addrs, _ := ifaces[0].Addrs()

	log.Printf("Response generated by " + addrs[0].String() + " (" + hostname + ")")
}
